#!/usr/bin/env bash
# -*- mode: sh -*-
# shellcheck disable=SC2155

# BSD 2-Clause License
#
# Copyright (c) 2022, Dmitry Klionsky
# All rights reserved.

#:  * `cache` [<options>]
#:
#:  Query the local Homebrew packages cache
#:
#:      -u                    Update/build the local packages cache
#:      -s  <[/]pattern[/]>     Search for package(s) that own the file pattern
#:      -d                    Display any debugging information
#:      -q                    Make some output more quiet
#:      -h, --help            Show this message

: "${BASE_NAME:=$(basename "$0")}"
: "${RDNS_NAME:="com.github.ten0s.${BASE_NAME}"}"
: "${CACHE_DIR:=""}"
: "${LIMIT_TO_PKGS:=""}"

usage() {
    brew cache --help
}

log_debug() {
  local msg="$*"
  [[ ${DEBUG:-0} -eq 1 ]] && printf "%s\n" "${msg}"
}

log_info() {
  local msg="$*"
  [[ ${QUIET:-0} -eq 0 ]] && printf "%s\n" "${msg}"
}

dump_info() {
  log_debug "Search   : ${SEARCH}"
  log_debug "Debug    : ${DEBUG:-0}"
  log_debug "Quiet    : ${QUIET:-0}"
  log_debug "Cache dir: ${CACHE_DIR}"
}

init() {
  case $(uname -s) in
    Linux)  CACHE_DIR=${XDG_CACHE_HOME-$HOME/.cache}/${RDNS_NAME} ;;
    Darwin) CACHE_DIR=$HOME/Library/Caches/${RDNS_NAME} ;;
    *)      echo "Error: Unsupported platform"; exit 1; ;;
  esac
  mkdir -p "${CACHE_DIR}"
  CACHE_CURRENT_FILE=${CACHE_DIR}/homebrew-current.cache
}

latest_hash() {
    # Extract the current git HEAD revision
    sed -rn -- "s/^Core tap HEAD: (.*)$/\1/p" <(brew --config)
}

current_hash() {
    [[ -f "${CACHE_CURRENT_FILE}" ]] && cat "${CACHE_CURRENT_FILE}"
}

cache_file() {
    local cache_hash=${1?}
    echo "${CACHE_DIR}/homebrew-${cache_hash}.cache"
}

cache_exists() {
    if [[ -f ${CACHE_CURRENT_FILE} ]]; then
        [[ -f $(cache_file "$(current_hash)") ]]
    else
        return 1
    fi
}

build_cache() {
    local new_cache_hash=${1?}
    log_info "Building cache: ${new_cache_hash}"

    # Create cache file
    NEW_CACHE=$(cache_file "${new_cache_hash}")
    while read -r pkg version; do
        log_debug "Working on: $pkg $version"
        while read -r file; do
            printf "%s:%s:%s\n" "${file}" "${pkg}" "${version}"
        done <<<"$(brew list --verbose "${pkg}")" >> "${NEW_CACHE}"
    done <<<"$(brew list --formula --versions | grep -E -- "${LIMIT_TO_PKGS}" )"

    # Remove previous cache file
    local prev_hash=$(current_hash)
    [[ -n ${prev_hash} ]] && rm -f "$(cache_file "${prev_hash}")"

    # Add hash to current cache file
    echo "${new_cache_hash}" > "${CACHE_CURRENT_FILE}"

    log_info "Cache: ${new_cache_hash} is built"
}

update_cache() {
    local current_hash=$(current_hash)
    local latest_hash=$(latest_hash)

    if cache_exists; then
        log_info "Current cache: ${current_hash}"
        if [[ "${current_hash}" == "${latest_hash}" ]]; then
            log_info "Cache: ${current_hash} is up-to-date"
        else
            log_info "Latest cache: ${latest_hash} is available"
            build_cache "${latest_hash}"
        fi
    else
        build_cache "${latest_hash}"
    fi
}

search_cache() {
    local new_cache_hash=${1?}

    log_debug "Searching: \`${SEARCH}\` in cache: ${new_cache_hash}"
    sed -rn -- "s@(.*)${SEARCH}(.*):(.*):(.*)@\3 \4@p" "$(cache_file "${new_cache_hash}")" | sort -u
}

check-and-search-cache() {
  if [[ ${SEARCH} != "" ]]; then
      if cache_exists; then
          search_cache "$(current_hash)"
      else
          echo "Error: No cache found. Run 'brew cache -u'"
          exit 1
      fi
  fi
}

[[ $# -eq 0 ]] && { usage; exit 1; } || init
while getopts us:dqh OPT; do
    case "$OPT" in
        u) update_cache ;;
        s) SEARCH="$OPTARG"; check-and-search-cache; ;;
        d) DEBUG=1; dump_info; ;;
        q) QUIET=1 ;;
        h) usage ;;
        *) log_info "Unknown option: $OPT"; usage; exit 1; ;;
    esac
done

