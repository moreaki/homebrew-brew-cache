#!/usr/bin/env bash
# -*- mode: sh -*-
# shellcheck disable=SC2155

# BSD 2-Clause License
#
# Copyright (c) 2022, Dmitry Klionsky
# All rights reserved.

#:  * `cache` [<options>]
#:
#:  Query the local Homebrew packages cache
#:
#:   -u            Update/build the local packages cache
#:   -s  <pattern>   Show package(s) owning the file(s) <pattern>
#:   -d            Display debugging information
#:   -i            Display cache information
#:   -q            Quiesce output
#:   -h, --help    Show this message

: "${BASE_NAME:=$(basename "$0")}"
: "${RDNS_NAME:="com.github.ten0s.${BASE_NAME}"}"
: "${CACHE_DIR:=""}"
: "${LIMIT_TO_PKGS:=""}"

init() {
  case $(uname -s) in
    Linux)  CACHE_DIR=${XDG_CACHE_HOME-$HOME/.cache}/${RDNS_NAME} ;;
    Darwin) CACHE_DIR=$HOME/Library/Caches/${RDNS_NAME} ;;
    *)      echo "Error: Unsupported platform"; exit 1; ;;
  esac
  mkdir -p "${CACHE_DIR}"
}

usage() {
    # https://github.com/Homebrew/brew/blob/3070fd7fef87ad60cfbeedda99233f8926174c9b/Library/Homebrew/cli/parser.rb#L11 breaks this output
    brew cache --help; exit 0
}

log_info() {
  local msg=${1}
  local hash="${2:-$(current_hash)}"
  [[ ${QUIET:-0} -eq 0 ]] && printf "%s %s\n" "[${hash:0:7}]" "${msg}"
}

log_debug() {
  [[ ${DEBUG:-0} -eq 1 ]] && log_info "$*"
}

dump_info() {
  log_info "Cache dir: ${CACHE_DIR}"
}

latest_hash() {
    # Extract brew's current git HEAD revision
    sed -rn -- "s/^Core tap HEAD: (.*)$/\1/p" <(brew --config)
}

current_hash() {
    sed -rn -- "s@(.*)/homebrew-(.*).cache@\2@p" <<<"$(find "${CACHE_DIR}"/homebrew-* -type f 2>/dev/null)"
}

cache_file() {
    local cache_hash=${1?}
    echo "${CACHE_DIR}/homebrew-${cache_hash}.cache"
}

cache_exists() {
    [[ -n "$(current_hash)" ]] && return 0 || return 1
}

build_cache() {
    local new_cache_hash=${1?}
    log_info "Building cache" "${new_cache_hash}"

    # Create cache file
    NEW_CACHE=$(cache_file "${new_cache_hash}")
    while read -r pkg version; do
        log_debug "Working on: $pkg $version"
        while read -r file; do
            printf "%s:%s:%s\n" "${file}" "${pkg}" "${version}"
        done <<<"$(brew list --verbose "${pkg}")" >> "${NEW_CACHE}"
    done <<<"$(brew list --formula --versions | grep -E -- "${LIMIT_TO_PKGS}")"

    # Remove previous cache file
    local prev_hash=$(current_hash)
    [[ -n ${prev_hash} ]] && rm -f "$(cache_file "${prev_hash}")"

    log_info "Cache is built" "${new_cache_hash}"
}

update_cache() {
    local current_hash=$(current_hash)
    local latest_hash=$(latest_hash)

    if cache_exists; then
        if [[ "${current_hash}" == "${latest_hash}" ]]; then
            log_info "Cache is up-to-date"
        else
            log_info "Updated git hash (${latest_hash:0:7}) is available, update cache"
            build_cache "${latest_hash}"
        fi
    else
        log_info "No cache is available, building new cache"
        build_cache "${latest_hash}"
    fi
}

search_cache() {
    local cache_hash=${1?}

    log_debug "Searching: \`${SEARCH}\` in cache: ${cache_hash}"
    sed -rn -- "s@(.*)${SEARCH}(.*):(.*):(.*)@\3 \4@p" "$(cache_file "${cache_hash}")" | sort -u
}

check-and-search-cache() {
  if [[ ${SEARCH} != "" ]]; then
      if cache_exists; then
          search_cache "$(current_hash)"
      else
          echo "Error: No cache found. Run \`brew cache -u\`"
          exit 1
      fi
  fi
}

[[ $# -eq 0 ]] && usage || init
while getopts us:diqh OPT; do
    case "$OPT" in
        u) update_cache ;;
        s) SEARCH="$OPTARG"; check-and-search-cache; ;;
        d) DEBUG=1; ;;
        i) dump_info; ;;
        q) QUIET=1 ;;
        h) usage ;;
        *) log_info "Unknown option: $OPT"; usage; ;;
    esac
done
